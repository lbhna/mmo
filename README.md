一、引子

很多时候我们都会想将一个本地构造好的对象，通过网络或者其它手段传输给另一个应用或者终端，可以让他直接使用这个对象的所有方法并访问其属性。
正常情况下，我们都会选择一种序列化方法，先将要传输的对象序列化成一种数据结构。比如：PB,FB,JSON,HESSION,甚至是自定义的binary结构。通过网络分发包含这种结构的内存块，然后，在另一端按照约定的规格将之反序列化成内存对象，进而实现对象传输与访问的目的。
如下图：
普通 方式下内存对象的传输流程：

这种方式大多数情况下都可以工作得很好。但是，在高并发的场景下（比如：10万QPS，每次请求传输1万对象），情况就不太乐观了，基本上大部分算力都消耗在序列化与反序列化上了。
如果我们设计一种对象存储的方式，使其不用进行序列化和反序列化的操作，也可以完美的传递对象到另一端，那剩下的开销就只有网络I/O问题了。
有没有这样的方法呢？我们研究发现，利用偏移指针的特性，完全可以实现。

三、具体实现

第一步：实现不定长偏移指针

第二步：实现一个内存池
用于接管对象构造过程中的内存分配，确保其构建在一个连续的空间中。这样有2个好处：
1、确保对象在一个连续的内存空间中，便于获取这块连续的内存并用于传输和分发。
2、寻址空间被限定在一个连续地址上，偏移地址的大小可控，可以对偏移指针本身的大小进行调整，减少内存占用。

第二步：定制偏移指针的容器
为了支持更复杂的对象表达，需要定制一些对象，如 ：string , vector ,list ,map ,hash_map 等。

第三步：构造需要传递的对象
利用内存池和定制容器，定义并构造在线性空间上分布的 对象

第四步：
通过网络等任意方式 分发该对象的内存块，
在接收方直接将 接收到的内存块映射成同类型的内存对象，直接访问即可。
这中间没有序列化、反序列化的过程。

四、应用&效果
1、应用场景
● 网络传输分发复杂对象
● 共享内存共享复杂对象
● 复杂对象的快速save&load


五、优缺点
优点：
1、无序列化、反序列化、内存转换复制 的操作，性能极好
2、偏移指针分场景定制的大小，极大的节省内存，特别是对象复杂，层次较深的情况。
3、同一对象，内存分布较连续，提升了缓存命中率，有一定的性能收益
缺点：
1、新旧兼容性问题
由于是内存对象直接映射的，是半兼容状态，无法做到新旧相互完全兼容。
半兼容是指：接收方老的规格可以兼容新规格的数据，但是，新的规格无法兼容旧的数据。
2、构造后只读的问题
由于本结构的定位是对象的分发和传递，并不支持对象的各种修改操作等。
为了构造时不留下冗余的内存空洞，因此设计时并没有提供修改的接口。
